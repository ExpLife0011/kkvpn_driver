#include "DriverInit.h"

#include "FilteringEngine.h"
#include "InjectionEngine.h"
#include "UserModeBufferHandler.h"

//#include <ntddk.h>
//#include <wdf.h>
//
//#pragma warning(push)
//#pragma warning(disable:4201)       // unnamed struct/union
//#include <fwpsk.h>
//#pragma warning(pop)
//
//#include <fwpmk.h>

DECLARE_CONST_UNICODE_STRING(
	SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R,
	L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)"
	);
	
BOOLEAN gStoppingThread;
KKDRV_WORKER_DATA gParams;

UINT64 gActiveFilter;
UINT32 gCalloutID;
IF_INDEX gIfIndex;
IF_INDEX gSubIfIndex;

PKEVENT gBufferEvent;
PKEVENT gUserModeEventReceive;
PKEVENT gUserModeEventComplete;
PKEVENT gThreadEvent;
PMDL gMdl;

HANDLE gFilteringEngineHandle;
HANDLE gInjectionEngineHandle;
PVOID gUASharedMem;
PVOID gSharedMem;
NDIS_HANDLE gPoolHandle;
PDEVICE_OBJECT gDeviceObject;

KKDRV_PACKET_QUEUE gPacketQueue;

VOID
kkVPNUnload(
	_In_ PDRIVER_OBJECT pDriverObject
	)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	gStoppingThread = TRUE;

	StopWorker();

	StopInjectionEngine(
		&gInjectionEngineHandle
		);

	StopFilterEngine(
		&gFilteringEngineHandle,
		&gCalloutID,
		&gActiveFilter
		);

	NdisFreeNetBufferListPool(gPoolHandle);
}

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT  pDriverObject,
	_In_ PUNICODE_STRING pRegistryPath
	)
{
	NTSTATUS status;
	WDFDRIVER driver;
	WDF_DRIVER_CONFIG config;
	
	WDF_DRIVER_CONFIG_INIT(&config, kkdrvDriverDeviceAdd);
	config.DriverInitFlags = 

	status = WdfDriverCreate(
			pDriverObject, 
			pRegistryPath, 
			WDF_NO_OBJECT_ATTRIBUTES, 
			&config, 
			&driver
			);

	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfDriverCreate, status);
		goto Exit;
	}

	pDriverObject->DriverUnload = kkVPNUnload;

	NET_BUFFER_LIST_POOL_PARAMETERS pool_params;

	RtlZeroMemory(&pool_params, sizeof(pool_params));
	pool_params.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
	pool_params.Header.Revision = NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;
	pool_params.Header.Size = sizeof(pool_params);
	pool_params.fAllocateNetBuffer = TRUE;
	pool_params.PoolTag = KKDRV_TAG;
	pool_params.DataSize = 0;
	gPoolHandle = NdisAllocateNetBufferListPool(NULL, &pool_params);
	if (gPoolHandle == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		REPORT_ERROR(NdisAllocateNetBufferListPool, status);
		goto Exit;
	}

	KeInitializeSpinLock(&(gPacketQueue.lock));

Exit:
	return status;
}

NTSTATUS 
kkdrvDriverDeviceAdd(
	_In_     WDFDRIVER Driver,
	_Inout_  PWDFDEVICE_INIT DeviceInit
	)
{
	UNREFERENCED_PARAMETER(Driver);

	NTSTATUS status = STATUS_SUCCESS;
	WDFDEVICE device;
	WDFQUEUE queue;
	WDF_OBJECT_ATTRIBUTES deviceAttributes = { 0 };
	WDF_OBJECT_ATTRIBUTES_INIT(&deviceAttributes);

	deviceAttributes.EvtCleanupCallback = kkdrvCleanupCallback;
	//deviceAttributes.Size = sizeof(deviceAttributes);

	//WdfDeviceInitSetCharacteristics(DeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);
	WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_NETWORK);
	WdfDeviceInitSetCharacteristics(DeviceInit, FILE_DEVICE_SECURE_OPEN, TRUE);
	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfDeviceCreate, status);
		WdfDeviceInitFree(DeviceInit);
		goto Exit;
	}

	status = CreateQueue(&device, &queue);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(CreateQueue, status);
		goto Exit;
	}

	DECLARE_CONST_UNICODE_STRING(dosDeviceName, DOS_DEVICE_NAME);
	status = WdfDeviceCreateSymbolicLink(
		device,
		&dosDeviceName
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfDeviceCreateSymbolicLink, status);
		goto Exit;
	}

	/*status = WdfDeviceCreateDeviceInterface(
		device,
		(LPGUID)&GUID_KKDRV_INTERFACE,
		NULL
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfDeviceCreateDeviceInterface, status);
		goto Exit;
	}*/

	WdfControlFinishInitializing(device);

	status = StartFilterEngine(
		&gFilteringEngineHandle,
		&gCalloutID,
		&gActiveFilter,
		device
		);

	status = StartInjectionEngine(
		&gInjectionEngineHandle
		);

	gUASharedMem = NULL;
	gSharedMem = NULL;
	gMdl = NULL;

Exit:
	return status;
}

NTSTATUS 
CreateQueue(
	_In_ WDFDEVICE *hDevice,
	_Out_ WDFQUEUE *hQueue
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	WDF_IO_QUEUE_CONFIG  ioQueueConfig;

	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(
		&ioQueueConfig,
		WdfIoQueueDispatchSequential
		);

	ioQueueConfig.PowerManaged = FALSE;
	ioQueueConfig.EvtIoDeviceControl = kkdrvIoDeviceControl;
	ioQueueConfig.EvtIoWrite = kkdrvIoWrite;

	status = WdfIoQueueCreate(
		*hDevice,
		&ioQueueConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		hQueue
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfIoQueueCreate, status);
		goto Exit;
	}

Exit:
	return status;
}

VOID 
kkdrvIoDeviceControl(
	_In_  WDFQUEUE Queue,
	_In_  WDFREQUEST Request,
	_In_  size_t OutputBufferLength,
	_In_  size_t InputBufferLength,
	_In_  ULONG IoControlCode
	)
{
	UNREFERENCED_PARAMETER(OutputBufferLength);
	UNREFERENCED_PARAMETER(InputBufferLength);

	NTSTATUS status = STATUS_SUCCESS;
	WDFDEVICE device = WdfIoQueueGetDevice(Queue);
	KKDRV_FILTER_DATA *data = NULL;
	PVOID uaMem = NULL;
	size_t bytes_read = 0;
	size_t bytes_returned = 0;

	switch (IoControlCode) 
	{
		case IOCTL_REGISTER:
			status = WdfRequestRetrieveInputBuffer(
				Request,
				1, //sizeof(KKDRV_FILTER_DATA),
				(void*)&data,
				&bytes_read
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(WdfRequestRetrieveInputBuffer, status);
				goto Complete;
			}

			UnMapAndFreeMemory(gMdl, gUASharedMem);
			gMdl = NULL;
			gUASharedMem = NULL;
			status = CreateAndMapMemory(
				&gMdl,
				&gUASharedMem
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(CreateAndMapMemory, status);
				goto Complete;
			}

			gSharedMem = MmGetSystemAddressForMdlSafe(gMdl, NormalPagePriority);
			if (!gSharedMem)
			{
				REPORT_ERROR(MmGetSystemAddressForMdlSafe, 0);
				goto Complete;
			}

			NT_ASSERT(data->event_receive != NULL);
			NT_ASSERT(data->event_completed != NULL);
			ObReferenceObjectByHandle(
				data->event_receive,
				0, NULL,
				UserMode,
				&gUserModeEventReceive,
				NULL
				);
			ObReferenceObjectByHandle(
				data->event_completed,
				0, NULL,
				UserMode,
				&gUserModeEventComplete,
				NULL
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(ObReferenceObjectByHandle, status);
				goto Complete;
			}

			status = RegisterFilter(
				data,
				gFilteringEngineHandle,
				&gActiveFilter
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(RegisterFilter, status);
				goto Complete;
			}

			status = WdfRequestRetrieveOutputBuffer(
				Request,
				sizeof(PVOID),
				&uaMem,
				NULL
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(WdfRequestRetrieveOutputBuffer, status);
				goto Complete;
			}

			*(PVOID*)uaMem = gUASharedMem;
			bytes_returned = sizeof(void*);
			break;

		case IOCTL_RESTART:
			bytes_returned = 0;

			status = RestartEngine(
				&gFilteringEngineHandle,
				&gCalloutID,
				&gActiveFilter,
				device
				);

			gStoppingThread = TRUE;
			//StopWorker();
			break;

		default:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

Complete:
	WdfRequestCompleteWithInformation(Request, status, bytes_returned);
}

VOID 
kkdrvCleanupCallback(
	_In_  WDFOBJECT Object
	)
{
	UNREFERENCED_PARAMETER(Object);

	UnMapAndFreeMemory(
		gMdl,
		gUASharedMem
		);
}

VOID 
kkdrvIoWrite(
	_In_  WDFQUEUE Queue,
	_In_  WDFREQUEST Request,
	_In_  size_t Length
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PVOID data = NULL;
	size_t bytesRead = 0;

	UNREFERENCED_PARAMETER(Queue);
	UNREFERENCED_PARAMETER(Length);

	status = WdfRequestRetrieveInputBuffer(
		Request,
		1,
		&data,
		&bytesRead
		);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfRequestRetrieveInputBuffer, status);
		WdfRequestCompleteWithInformation(Request, status, (ULONG_PTR)0);
	}

	InjectPacketReceive(
		gInjectionEngineHandle,
		data,
		bytesRead,
		&Request
		);
}

NTSTATUS 
CreateAndMapMemory(
	PMDL* PMemMdl, 
	PVOID* UserVa
	)
{
	PMDL mdl;
	PVOID userVAToReturn;
	PHYSICAL_ADDRESS lowAddress;
	PHYSICAL_ADDRESS highAddress;
	SIZE_T totalBytes;

	lowAddress.QuadPart = 0;
	highAddress.QuadPart = 0xFFFFFFFF;
	totalBytes = PAGE_SIZE*UM_BUFFER_PAGE_COUNT;

	mdl = MmAllocatePagesForMdl(lowAddress, highAddress, lowAddress, totalBytes);

	if (!mdl)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	userVAToReturn =
		MmMapLockedPagesSpecifyCache(
			mdl,
			UserMode,     
			MmCached,     
			NULL,         
			FALSE,        
			NormalPagePriority
			);
	if (!userVAToReturn)
	{
		MmFreePagesFromMdl(mdl);
		IoFreeMdl(mdl);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	*UserVa = userVAToReturn;
	*PMemMdl = mdl;

	return STATUS_SUCCESS;
}

void 
UnMapAndFreeMemory(
	PMDL PMdl, 
	PVOID UserVa
	)
{
	if (!PMdl) 
	{
		return;
	}

	MmUnmapLockedPages(UserVa, PMdl);

	MmFreePagesFromMdl(PMdl);
	IoFreeMdl(PMdl);
}