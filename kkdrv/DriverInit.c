#include <ntddk.h>
#include <wdf.h>
#include "DriverInit.h"
#include "FilteringEngine.h"
#include "CommonStructures.h"
#include "InjectionEngine.h"
#include "UserModeBufferHandler.h"

DECLARE_CONST_UNICODE_STRING(
SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R,
L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)"
);

BOOLEAN gDriverStopping;
KKDRV_WORKER_DATA gParams;

UINT64 gActiveFilter;
UINT32 gCalloutID;

PKEVENT gBufferEvent;
PKEVENT gUserModeEvent;
PKEVENT gThreadEvent;
PMDL gMdl;

HANDLE gFilteringEngineHandle;
HANDLE gInjectionEngineHandle;
PVOID gUASharedMem;
PVOID gSharedMem;

VOID
kkVPNUnload(
	_In_ PDRIVER_OBJECT pDriverObject
	)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	gDriverStopping = TRUE;

	StopWorker();

	StopInjectionEngine(
		&gInjectionEngineHandle
		);

	StopFilterEngine(
		&gFilteringEngineHandle,
		&gCalloutID,
		&gActiveFilter
		);

	DbgPrint(_DRVNAME "Unloaded\n");
}

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT  pDriverObject,
	_In_ PUNICODE_STRING pRegistryPath
	)
{
	NTSTATUS status;
	WDFDRIVER driver;
	WDF_DRIVER_CONFIG config;
	
	DbgPrint(_DRVNAME "Started (Version " _DRVVER ")\n");
	WDF_DRIVER_CONFIG_INIT(&config, kkdrvDriverDeviceAdd);
	status = WdfDriverCreate(
			pDriverObject, 
			pRegistryPath, 
			WDF_NO_OBJECT_ATTRIBUTES, 
			&config, 
			&driver
			);

	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfDriverCreate, status);
		goto Exit;
	}

	pDriverObject->DriverUnload = kkVPNUnload;

Exit:
	return status;
}

NTSTATUS 
kkdrvDriverDeviceAdd(
	_In_     WDFDRIVER Driver,
	_Inout_  PWDFDEVICE_INIT DeviceInit
	)
{
	UNREFERENCED_PARAMETER(Driver);

	NTSTATUS status = STATUS_SUCCESS;
	WDFDEVICE device;
	WDFQUEUE queue;
	WDF_OBJECT_ATTRIBUTES deviceAttributes = { 0 };
	WDF_OBJECT_ATTRIBUTES_INIT(&deviceAttributes);

	deviceAttributes.EvtCleanupCallback = kkdrvCleanupCallback;
	//deviceAttributes.Size = sizeof(deviceAttributes);

	//WdfDeviceInitSetCharacteristics(DeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);
	WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_NETWORK);
	WdfDeviceInitSetCharacteristics(DeviceInit, FILE_DEVICE_SECURE_OPEN, TRUE);
	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfDeviceCreate, status);
		WdfDeviceInitFree(DeviceInit);
		goto Exit;
	}
	DbgPrint(_DRVNAME "Device created\n");

	status = CreateQueue(&device, &queue);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(CreateQueue, status);
		goto Exit;
	}
	DbgPrint(_DRVNAME "Device I/O queue created\n");

	DECLARE_CONST_UNICODE_STRING(dosDeviceName, DOS_DEVICE_NAME);
	status = WdfDeviceCreateSymbolicLink(
		device,
		&dosDeviceName
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfDeviceCreateSymbolicLink, status);
		goto Exit;
	}
	DbgPrint(_DRVNAME "Symbolic link created\n");

	UNICODE_STRING ref;
	RtlInitUnicodeString(&ref, L"kkdrvrefstring");
	status = WdfDeviceCreateDeviceInterface(
		device,
		(LPGUID)&GUID_KKDRV_INTERFACE,
		NULL //&ref
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfDeviceCreateDeviceInterface, status);
		goto Exit;
	}
	DbgPrint(_DRVNAME "Device interface created\n");

	WdfControlFinishInitializing(device);
	DbgPrint(_DRVNAME "Device initialization finished\n");

	status = StartFilterEngine(
		&gFilteringEngineHandle,
		&gCalloutID,
		&gActiveFilter,
		device
		);

	status = StartInjectionEngine(
		&gInjectionEngineHandle
		);

	gUASharedMem = NULL;
	gSharedMem = NULL;
	gMdl = NULL;

Exit:
	return status;
}

NTSTATUS 
CreateQueue(
	_In_ WDFDEVICE *hDevice,
	_Out_ WDFQUEUE *hQueue
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	WDF_IO_QUEUE_CONFIG  ioQueueConfig;

	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(
		&ioQueueConfig,
		WdfIoQueueDispatchSequential
		);

	ioQueueConfig.EvtIoDeviceControl = kkdrvIoDeviceControl;
	ioQueueConfig.EvtIoRead = kkdrvIoRead;
	ioQueueConfig.EvtIoWrite = kkdrvIoWrite;

	status = WdfIoQueueCreate(
		*hDevice,
		&ioQueueConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		hQueue
		);
	if (!NT_SUCCESS(status)) {
		REPORT_ERROR(WdfIoQueueCreate, status);
		goto Exit;
	}

Exit:
	return status;
}

VOID kkdrvIoDeviceControl(
	_In_  WDFQUEUE Queue,
	_In_  WDFREQUEST Request,
	_In_  size_t OutputBufferLength,
	_In_  size_t InputBufferLength,
	_In_  ULONG IoControlCode
	)
{
	UNREFERENCED_PARAMETER(OutputBufferLength);
	UNREFERENCED_PARAMETER(InputBufferLength);

	NTSTATUS status = STATUS_SUCCESS;
	WDFDEVICE device = WdfIoQueueGetDevice(Queue);
	KKDRV_FILTER_DATA *data = NULL;
	PVOID uaMem = NULL;
	size_t bytes_read = 0;
	size_t bytes_returned = 0;

	switch (IoControlCode) 
	{
		case IOCTL_REGISTER:
			status = WdfRequestRetrieveInputBuffer(
				Request,
				1, //sizeof(KKDRV_FILTER_DATA),
				(void*)&data,
				&bytes_read
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(WdfRequestRetrieveInputBuffer, status);
				goto Complete;
			}

			DbgPrint(_DRVNAME "Device I/O Control recieved (event: 0x%0x)\n", 
				data->event
				);

			UnMapAndFreeMemory(gMdl, gUASharedMem);
			status = CreateAndMapMemory(
				&gMdl,
				&gUASharedMem
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(CreateAndMapMemory, status);
				goto Complete;
			}

			gSharedMem = MmGetSystemAddressForMdlSafe(gMdl, NormalPagePriority);
			if (!gSharedMem)
			{
				REPORT_ERROR(MmGetSystemAddressForMdlSafe, 0);
				goto Complete;
			}

			ObReferenceObjectByHandle(
				data->event,
				0, NULL,
				UserMode,
				&gUserModeEvent,
				NULL
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(ObReferenceObjectByHandle, status);
				goto Complete;
			}
			status = RegisterFilter(
				&device,
				data,
				gFilteringEngineHandle,
				&gActiveFilter,
				&gCalloutID
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(RegisterFilter, status);
				goto Complete;
			}

			status = WdfRequestRetrieveOutputBuffer(
				Request,
				sizeof(PVOID),							// called from 32-bit app, hence 32-bit pointer
				&uaMem,
				NULL
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(WdfRequestRetrieveOutputBuffer, status);
				goto Complete;
			}

			*(PVOID*)uaMem = gUASharedMem;
			bytes_returned = sizeof(uaMem);
			
			DbgPrint(_DRVNAME "Filter registered\n");
			break;

		case IOCTL_RESTART:
			status = RestartEngine(
				&gFilteringEngineHandle,
				&gCalloutID,
				&gActiveFilter,
				device
				);

			DbgPrint(_DRVNAME "Filter unregistered\n");
			break;

		/*case IOCTL_SET_EVENT_HANDLE:
			status = WdfRequestRetrieveInputBuffer(
				Request,
				sizeof(gUserModeEvent),
				(void*)&gUserModeEvent,
				&bytes_read
				);
			if (!NT_SUCCESS(status))
			{
				REPORT_ERROR(WdfRequestRetrieveInputBuffer, status);
				goto Complete;
			}

			DbgPrint(_DRVNAME "Event handle received\n");
			break;*/

		default:
			status = STATUS_INVALID_DEVICE_REQUEST;
			DbgPrint(_DRVNAME "Device I/O Control recieved (invalid IoControlCode)\n");
			break;
	}

Complete:
	WdfRequestCompleteWithInformation(Request, status, bytes_returned);
}

VOID kkdrvCleanupCallback(
	_In_  WDFOBJECT Object
	)
{
	UNREFERENCED_PARAMETER(Object);

	UnMapAndFreeMemory(
		gMdl,
		gUASharedMem
		);
}

VOID kkdrvIoRead(
	_In_  WDFQUEUE Queue,
	_In_  WDFREQUEST Request,
	_In_  size_t Length
	)
{
	NTSTATUS status = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(Queue);
	UNREFERENCED_PARAMETER(Request);
	UNREFERENCED_PARAMETER(Length);

//Complete:
	WdfRequestCompleteWithInformation(Request, status, (ULONG_PTR)0);
}

VOID kkdrvIoWrite(
	_In_  WDFQUEUE Queue,
	_In_  WDFREQUEST Request,
	_In_  size_t Length
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	PVOID data = NULL;
	size_t bytes_read = 0;

	UNREFERENCED_PARAMETER(Queue);
	UNREFERENCED_PARAMETER(Length);

	status = WdfRequestRetrieveInputBuffer(
		Request,
		1,
		data,
		&bytes_read
		);
	if (!NT_SUCCESS(status))
	{
		REPORT_ERROR(WdfRequestRetrieveInputBuffer, status);
		goto Complete;
	}

Complete:
	WdfRequestCompleteWithInformation(Request, status, (ULONG_PTR)0);
}

NTSTATUS CreateAndMapMemory(PMDL* PMemMdl, PVOID* UserVa)
{
	PMDL mdl;
	PVOID userVAToReturn;
	PHYSICAL_ADDRESS lowAddress;
	PHYSICAL_ADDRESS highAddress;
	SIZE_T totalBytes;

	lowAddress.QuadPart = 0;
	highAddress.QuadPart = 0xFFFFFFFF;
	totalBytes = PAGE_SIZE;

	mdl = MmAllocatePagesForMdl(lowAddress, highAddress, lowAddress, totalBytes);

	if (!mdl)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	userVAToReturn =
		MmMapLockedPagesSpecifyCache(
			mdl,
			UserMode,     
			MmCached,     
			NULL,         
			FALSE,        
			NormalPagePriority
			);
	if (!userVAToReturn)
	{
		MmFreePagesFromMdl(mdl);
		IoFreeMdl(mdl);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	*UserVa = userVAToReturn;
	*PMemMdl = mdl;

	DbgPrint(_DRVNAME "UserVA: 0x%0x\n", userVAToReturn);

	return STATUS_SUCCESS;
}

void UnMapAndFreeMemory(PMDL PMdl, PVOID UserVa)
{
	if (!PMdl) {
		return;
	}

	MmUnmapLockedPages(UserVa, PMdl);

	MmFreePagesFromMdl(PMdl);
	IoFreeMdl(PMdl);
}